在讲解利用Fortran怎样实现遗传算法之前，我先简单的介绍一下什么是遗传算法。



# 遗传算法

遗传算法属于进化算法，进化算法又是优化算法的一种。优化算法还包括各种梯度下降算法。总之这类算法是用来解决最优化问题的，尤其是算法复杂度为n!的NP问题。因为计算机的能力有限，但是解空间又异常的巨大，导致单纯的用枚举算法去解决问题效率会异常的低下(虽然能保证最优解)。例如旅行商问题(给定N个地点的坐标信息，设计出一条路线使得不重复遍历每个地点最终总路程最短。这个问题的解空间大小就是N!)，枚举计算时间长度会随N的增加而指数型增加。还有高维函数的最优解问题，若是一元函数切定义域为[0,1]，若要求解的精度为0.001，那么解空间的大小就为1000，此时只需要计算一个点就可以得到问题的答案，但是若是n元函数的高维问题，解空间的大小则就会变为1000^n(这里假设每个变量的定义域和所需精度相同)。实际上有很多问题当变量变多的时候就会导致指数灾难。那么此时优化算法就派上用场了，这里我仅谈进化算法，梯度下降算法的机理和进化算法的不太一样。

常见的求最优解问题的进化算法有遗传算法，模拟退火算法，粒子群算法和蚁群算法等。之所以叫进化算法，是由于这类算法中每次迭代后的结果和上一次的结果是有关联的，而且会随着时间发生变化。其中遗传算法的解空间为一种称之为染色体(Chrom)的集合，每个染色体对应于实际求解问题解空间中的一个解(其中染色体变换到解的过程称之为解码过程decode，该过程的逆过程称之为编码过程encode)，染色体变量本身的形式为一个列表(这个列表的元素称之为基因Gene)，分问题不同可以是普通数字，也可以是二进制代码(为了扩大变量的随机性，往往效果更好，但是难于理解)。另外还需要一个适应度函数用来判断当前解(染色体)的好坏，例如旅行商问题中的适应度函数就是总距离。这些算法又可以称之为仿生算法，算法的实现过程就是模拟一种真正存在的现象，例如遗传算法就是模拟染色体优胜劣汰遗传的过程，蚁群算法模拟的是蚂蚁寻觅食物的过程。从而算法中对染色体操作的几个过程的名字也比较有意思，分别为选择(Selection)，交叉(Crossover)和变异(Mutation)。整个算法最初是利用随机数均匀初始化一个给定个数的染色体数目(这个染色体的集合我们称之为种群Population)，染色体较为均匀的分布在整个解空间中，具体要撒多少个点，视具体问题而定。然后利用适应度函数计算出每个染色体的适应度。首先进行的就是选择操作，先将染色体由好到坏进行排序(最值问题就是从大到小或者从小到大)，然后挑选出一定比例最优的染色体，这个比例称之为存活率。接下来就是交叉操作，利用挑选出来的染色体两两相互进行随机交叉产生下一代染色体。交叉操作也有很多种，一般的就是随机互换两个染色体中某一个基因。最后一个步骤就是变异操作。和交叉操作一样这里要根据具体问题来确定具体变异方式，对于最值问题而言就是对于每个染色体，有一定概率这个染色体上的基因会发生变化，这个概率我们称之为变异率。变异率一般很小。这里就完成了一次迭代的操作，迭代的终止条件一般就是认为给规定的迭代次数。



更为详细的内容可参考https://www.zhihu.com/question/23293449
我的例子是求解f(x) = x+10*sin(5*x)+7*cos(4*x)最优解。具体代码请点击阅读原文。
例子来源于https://www.zhihu.com/question/23293449/answer/120220974
网友利用不同语言进行了解答，这里算是我补充了一个Fortran版本的方法。

代码:
```fortran
!----------------------------------------------------------------------------!
! genetic algorithm
!----------------------------------------------------------------------------!
module main_fun
    implicit none

    private
    public :: genetic

    type genetic
        private
        integer, public :: population, iter_num, numerical
        integer, public :: seed
        integer :: length, retain_num
        real, public :: mutation_rate = 0.01
        real, public :: retain_rate = 0.2
        real, public :: random_rate = 0.5
        real, public :: upperb, lowerb
        real, allocatable :: fitness(:), var(:)
        real, allocatable :: trace(:,:)
        integer, allocatable :: dec_len(:)
        integer, allocatable :: Chrom(:,:)
        procedure(func_fit), public, nopass, pointer :: func => null()
    contains
        private
        procedure :: Initialization
        procedure :: Crossover
        procedure :: Mutation
        procedure :: Selection
        procedure :: get_length
        procedure :: sort => sort_fitness
        procedure :: bin2dec => binary2decimal
        procedure, public :: Evolve => Evolution
        procedure, public :: Output
        final :: destructor
    end type genetic

    interface
        real function func_fit(x)
            implicit none
            real :: x
        end function func_fit
    end interface
contains
!------------------------------------------! 获得染色体长度
    subroutine get_length(this)
        implicit none
        class(genetic) :: this
        this%length = ceiling(log((this%upperb-this%lowerb) &
                             *10**(this%numerical))/log(2.0))
    end subroutine get_length
!------------------------------------------! 二进制 => 十进制
    subroutine binary2decimal(this)
        implicit none
        class(genetic) :: this
        integer :: pop_i

        do pop_i=1,this%population
            this%var(pop_i) = float(dot_product(this%dec_len,this%Chrom(:,pop_i)))
        end do
        this%var = this%lowerb + this%var*(this%upperb-this%lowerb)/(2.**this%length-1)
    end subroutine binary2decimal
!------------------------------------------! 适应度排序
    subroutine sort_fitness(this)
        implicit none
        class(genetic) :: this
        integer :: temp_chrom(this%length), pop_i, pop_j
        real :: temp_fit, temp_var
        call this%bin2dec()
        do pop_i=1,this%population
            this%fitness(pop_i) = this%func(this%var(pop_i))
        end do

        do pop_i=1,this%population-1
            do pop_j=1,this%population-1
                if(this%fitness(pop_j)<this%fitness(pop_j+1)) then
                    temp_var = this%var(pop_j)
                    this%var(pop_j) = this%var(pop_j+1)
                    this%var(pop_j+1) = temp_var

                    temp_fit = this%fitness(pop_j)
                    this%fitness(pop_j) = this%fitness(pop_j+1)
                    this%fitness(pop_j+1) = temp_fit

                    temp_chrom = this%Chrom(:,pop_j+1)
                    this%Chrom(:,pop_j) = this%Chrom(:,pop_j+1)
                    this%Chrom(:,pop_j+1) = temp_chrom
                end if
            end do
        end do
    end subroutine sort_fitness
!------------------------------------------! 初始化
    subroutine Initialization(this)
        implicit none
        integer :: i, pop_i
        real :: first_random
        class(genetic) :: this
        call get_length(this)
        allocate(this%Chrom(this%length,this%population))
        allocate(this%fitness(this%population))
        allocate(this%var(this%population))
        allocate(this%dec_len(this%length))
        allocate(this%trace(2,this%iter_num))
        this%trace = 0.0
        forall(i=1:this%length) this%dec_len(i)=2**(i-1)

        first_random = rand(this%seed)
        do pop_i=1,this%population
            do i=1,this%length
                if(ran()>0.5) then
                    this%Chrom(i,pop_i) = 0
                else
                    this%Chrom(i,pop_i) = 1
                end if
            end do
        end do
    end subroutine Initialization
!------------------------------------------! 演化
    subroutine Evolution(this)
        implicit none
        class(genetic) :: this
        integer :: i, max_i(1)

        call this%Initialization()  ! 初始化
        do i=1,this%iter_num
            call this%Selection()   ! 选择
            call this%Crossover()   ! 交叉
            call this%Mutation()    ! 变异
            max_i = maxloc(this%fitness)
            this%trace(1,i) = this%var(max_i(1))
            this%trace(2,i) = this%fitness(max_i(1))
        end do
    end subroutine Evolution
!------------------------------------------! 选择
    subroutine Selection(this)
        implicit none

        class(genetic) :: this
        integer :: pop_i, pop_j, num
        integer, dimension(:,:), allocatable :: newChrom
        allocate(newChrom(this%length,this%population))

        call this%sort()
        this%retain_num = ceiling(this%population*this%retain_rate)
!        newChrom = 0
        newChrom(:,1:this%retain_num) = this%Chrom(:,1:this%retain_num)
        pop_j = this%retain_num+1
        num = 0
        do pop_i=this%retain_num+1,this%population
            if(this%random_rate>ran()) then
                newChrom(:,pop_j) = this%Chrom(:,pop_i)
                pop_j = pop_j + 1
                num = num + 1
            end if
        end do
        this%Chrom = newChrom
        this%retain_num = this%retain_num + num
        deallocate(newChrom)
    end subroutine Selection
!------------------------------------------! 交叉
    subroutine Crossover(this)
        implicit none
        class(genetic) :: this
        integer :: pop_i, j
        integer, allocatable :: male(:), female(:), child(:)
        allocate(male(this%length),female(this%length),child(this%length))
        do pop_i=this%retain_num+1,this%population
            male = this%Chrom(:,ceiling(this%retain_num*ran()))
            female = this%Chrom(:,ceiling(this%retain_num*ran()))
            do j=1,this%length
                if(ran()>0.5) then
                    child(j) = male(j)
                else
                    child(j) = female(j)
                end if
            end do
            this%Chrom(:,pop_i) = child
        end do
        deallocate(male,female,child)
    end subroutine Crossover
!------------------------------------------! 变异
    subroutine Mutation(this)
        implicit none
        class(genetic) :: this
        integer :: pop_i, i
        do pop_i=this%retain_num+1,this%population
            if(this%mutation_rate>ran()) then
                i = ceiling(this%length*ran())
                this%Chrom(i,pop_i) = 1 - this%Chrom(i,pop_i)  ! 1=>0, 0=>1
            end if
        end do
    end subroutine Mutation
!------------------------------------------! 输出
    subroutine Output(this)
        implicit none
        class(genetic) :: this
        integer :: i
        open(10, file = 'trace.txt')
        do i=1,this%iter_num
            write(10,*) i, this%trace(:,i)
            write(*,*)  i, this%trace(:,i)
        end do
    end subroutine Output
    subroutine destructor(this)
        implicit none
        type(genetic) :: this
        deallocate(this%Chrom, this%fitness)
        deallocate(this%var, this%dec_len, this%trace)
    end subroutine destructor
end module
!----------------------------------------------------------------------------!
real function Fitness_func(x) ! sufficiency function
    implicit none
    real :: x
    Fitness_func = x + 10*sin(5*x) + 7*cos(4*x)
end function Fitness_func
!----------------------------------------------------------------------------!
program main
    use main_fun
    implicit none
    real, external :: Fitness_func

    type(genetic) :: process

    process%func => Fitness_func  ! 适应度函数 vector
    process%seed = 123456         ! 随机数种子
    process%iter_num = 100        ! 迭代次数
    process%population = 100      ! 种群大小
    process%numerical = 3         ! 有效数字
    process%retain_rate = 0.2     ! 存活率
    process%random_rate = 0.5     ! 随机率
    process%mutation_rate = 0.01  ! 变异率
    process%upperb = 9.0          ! 参数上限 vector
    process%lowerb = 0.0          ! 参数下限 vector

    call process%Evolve()
    call process%Output()

    stop
end program main
!----------------------------------------------------------------------------!

```

